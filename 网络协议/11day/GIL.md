## 并发和并行


### 什么是并发什么是并行,他们的区别是什么?


>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行.

>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后电话以后继续吃饭，这说明你支持并发。

>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
#### 并发：交替处理多个任务的能力
#### 并行：同时处理多个任务的能力

>并发的关键是你有处理多个任务的能力，不一定要同时。

>并行的关键是你有同时处理多个任务的能力,强调的是同时.

>所以它们最大的区别就是：是否是『同时』处理任务。


###### Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别
![](/Images/12day/并行并发执行.png)


> 两队人排队使用一个咖啡机, 就像两个任务使用一个单核cup,他们只能实现交替使用, 也就是说单核cup只能实现并发.

> 两队人排队使用两个咖啡机, 就像两个任务分别使用一个双核cpu的两个核,他们可以同时使用, 也就是说双核cup可以实现并行

> 对于一个多核cpu来说并行显然要比并发快的多

> 由此我们可以知道一个多核cpu在处理多个任务的时候如果想要发挥最大功效就要实现并行

> 那我们在使用多线程和多进程来写程序的时候就是为了让多核cup发挥他最大的功效实现并行, 也就是我们面试题参考答案的结果

### 代码验证多进程,多线程对cpu的使用情况
```python
#多线程
import threading

#子线程死循环
def test():
    while True:
        pass


t1 = threading.Thread(target=test)
t1.start()

#主线程死循环
while True:
    pass


```

```python
#多进程
import multiprocessing

def deadLoop():
    while True:
        pass

#子进程死循环
p1 = multiprocessing.Process(target=deadLoop)
p1.start()

#主进程死循环
deadLoop()
```
> 通过代码可以发现 多进程可以充分使用cpu的两个内核 而多线程却不能充分使用cpu的两个内核

> 问题 : 通过验证我们发现多线程并不能真正的让多核cpu实现并行

> 原因 : cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码,因此造成了我们使用多线程的时候无法实现并行
##### 解决方案法 :
##### 1:更换解释器 比如使用jpython(java实现的python解释器)
##### 2:使用多进程完成多任务的处理



## GIL（全局解释器锁）

#### GIL面试题如下

>描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。


Guido的声明：http://www.artima.com/forums/flat.jsp?forum=106&thread=214235

he language doesn't require the GIL -- it's only the CPython virtual machine that has historically been unable to shed it.

#### 参考答案:
> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。
> 3. 线程释放GIL锁的情况：
> 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL
> Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100
> 4. Python使用多进程是可以利用多核的CPU资源的。
> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁

### 结论:
### 1. 在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快
### 2. 在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程快
